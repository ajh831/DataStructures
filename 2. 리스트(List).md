# 리스트(List)

> **목차**
1. 배열
2. 단순 연결 리스트
3. 이중 연결 리스트
4. 원형 연결 리스트
> 

## 1. 배열(Array)

동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 각 항목이 하나의 원소에 저장되는 기본적인 자료구조이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/63c824a3-9d78-438b-9a73-86f9ccf3c20d/Untitled.png)

배열은 미리 정해진 크기의 메모리 공간을 할당 받은 뒤 사용해야 하므로 Overflow상황에 직면할 수 도 있다.

- 배열에 overflow가 발생하면 배열 크기를 2배로 확장하여 해결 할 수 있다.
- 반대로 배열의 3/4이 비어 있다면 배열 크기를 1/2로 축소 할 수도 있다.

### 💡포인트

- 접근 : O(1)
    - 특정 원소에 접근 할 때는 배열의 인덱스를 이용하기 때문에 O(1) 시간에 접근 할 수 있다.
- 삽입/삭제 : O(n)
    - 중간에 삽입/삭제를 진행하는 경우 뒤따르는 항목들을 1칸씩 앞/뒤로 이동해야 하므로 최악의 경우 O(n) 시간이 걸릴 수 있다.
- 맨뒤 삽입 : O(1)
    - 새로운 항목을 맨뒤에 추가하는 작업은 O(1) 시간에 수행이 가능하다.

## 2. 단순 연결 리스트(Singly Linked List)

동적 메모리 할당을 이용해 리스트를 구현하는 가장 간단한 형태의 자료구조이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/cd938818-29db-4ecb-91f9-1a59fa3ee8cb/Untitled.png)

1차원 배열과 달리 연결 리스트는 삽입/삭제 시 항목들의 이동이 필요 없다.

또한, 연결 리스트는 빈 공간이 존재하지 않는다.

연결 리스트에서 항목에 접근 또는 탐색을 하기 위해서는 `순차 탐색(Sequential Search)`를 해야하고, 각 노드마다 레퍼런스를 저장할 공간이 필요하다.

### 💡포인트

- 접근 : O(n)
    - 첫 노드부터 순차적으로 방문해야 하므로 건너 뛰면서 탐색할 수 없다.
- 맨 앞에 삽입/삭제 : O(1)
    - 단순히 노드 사이에 연결만 이루어지면(메모리 주소값만 변경해주면) 되기 때문에 속도가 빠르다.
        
        → 상수 개의 레퍼런스를 갱신
        
- 중간 삽입/삭제 : O(n)
    - head로 부터 노드를 찾기 위해 리스트를 순차 탐색해야 하므로 오래걸린다.

연결 리스트 추가 시 O(n)을 O(1)로 변경하는 방법

- 삽입을 맨 앞에 해준 뒤 나중에 한 번만 뒤집어 주면 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/35962227-f837-4590-98c7-aba12d4cc201/Untitled.png)

- 예시

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/80115489-8380-4cae-8dd0-ded3f4401d14/Untitled.png)

## 3. 이중 연결 리스트(Doubly Linked List)

각 노드가 두 개의 레퍼런스를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결 리스트이다.

단순 연결 리스트의 역방향으로 리스트를 탐색할 수 없다는 단점을 보완하였다. 단, 노트마다 추가로 1개의 레퍼런스를 저장해야 된다는 단점을 가진다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/1a8bfe1e-4e7f-4f69-b1dd-98cbf9d2099d/Untitled.png)

### 💡포인트

- 접근 : O(n)
    - head 또는 tail로 부터 노드들을 순차적으로 탐색해야 하므로 오래걸린다.
- 맨 앞에 삽입/삭제 : O(1)
    - 단순히 노드 사이에 연결만 이루어지면(메모리 주소값만 변경해주면) 되기 때문에 속도가 빠르다.
        
        

## 4. 원형 연결 리스트(Circular Linked List)

마지막 노드가 첫 노드와 연결된 단순 연결 리스트이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/c7ad20c7-9109-41a5-9a72-5414ce868310/Untitled.png)

원형 연결 리스트는 어떤 노드도 null 레퍼런스를 가지고 있지 않다.

원형 연결 리스트는 반대 방향으로 접근하기 쉽지 않으며, 무한 루프가 발생할 수 있어 주의할 필요가 있다.

여러 사람이 차례로 돌아가며 진행하는 게임을 구현하는 데 적합한 자료구조이다.(ex 모두의 마블 턴 제)

많은 사용자가 동시에 사용하는 컴퓨터에서 cpu 시간을 분할하여 작업에 할당하는 운영체제에도 쓰인다.

우선순위 큐를 구현하는데도 부분적으로 사용된다.

### 💡포인트

- 마지막 노드, 첫 노드 접근 : O(1)
    - 첫 노드와 마지막 노드가 동일하기 때문에 둘다 동일하게 O(1) 시간에 접근할 수 있다.
- 삽입/삭제 : O(1)
    - 삽입/삭제할 노드가 주어지는 경우 레퍼런스만 변경해 주면 된다.
- 탐색 : O(n)
    - 노드들을 순차적으로 탐색해야 되므로 오래 걸린다.

## 요약

배열과 연결 리스트들의 최악의 경우 빅오(O) 수행 시간 비교

### 1차원 배열

- 접근 : O(1)
- 탐색 : O(n)
    - 정렬된 경우 : O(logn)
    ⇒ 이진 탐색을 사용 할 수 있게 됨
- 삽입 : O(n)
- 삭제 : O(n)

### 연결 리스트

삽입, 삭제할 노드의 이전 노드 레퍼런스가 주어진 경우

### 단순 연결 리스트

- 접근 : O(n)
- 탐색 : O(n)
- 삽입 : O(1)
- 삭제 : O(1)

### 이중 연결 리스트

- 접근 : O(n)
- 탐색 : O(n)
- 삽입 : O(1)
- 삭제 : O(1)

### 원형 연결 리스트

- 접근 : O(n)
- 탐색 : O(n)
- 삽입 : O(1)
- 삭제 : O(1)
