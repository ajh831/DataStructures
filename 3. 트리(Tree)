> 목차
1. 트리
2. 이진트리
3. 이진 트리의 연산
4. 서로소 집합을 위한 트리 연산
> 

트리 자료구조는 배열의 삽입/삭제 후 정렬 상태 유지하는데 드는 소요시간 문제점을 보완하였다.

## 1. 트리

일반적인 트리는 실제 트리를 거꾸로 세워 놓은 형태의 자료구조이다.

HTML과 XML의 문서 트리, 자바 클래스 계층구조, 운영체제의 파일 시스템, 탐색 트리, 이항(Binomial) 힙, 피보나치(Fibonacci) 힙과 같은 우선순위큐에서 사용된다.

### 트리 용어

- 루트(root) : 트리 최상위에 있는 노드
- 자식(child) : 노드 하위에 연결된 노드
- 차수(degree) : 자식의 수 (cf. Binary Tree는 차수가 2)
- 부모(parent) : 노드 상위에 연결된 노드
- 리프(leaf) : 자식이 없는 노드
- 형제(sibiling) : 동일한 부모를 가지는 노드
- 조상(ancestory) : 루트까지의 경로상에 있는 모든 노드의 집합
- 후손(descendant) : 노드 아래로 매달린 모든 노드의 집핮
- 서브트리(subtree) : 노드 자신과 후손으로 구성된 트리
- 레벨(level) : 루트가 레벨 1, 아래층으로 내려갈 수록 레벨 1씩 증가한다. 레벨은 깊이(depth)와 동일하다.
- 높이(height) : 트리의 최대 레벻
- 키(key) : 탐색에 사용되는 노드에 저장된 정보

<img width="723" alt="image" src="https://github.com/user-attachments/assets/9901acb1-7285-487f-a874-0a1e2fe9c405">


## 2 이진 트리

이진트리는 각 노드의 자식 수가 2 이하인 트리이다.

이진 트리는 데이터의 구조적인 관계를 잘 반영하고, 효율적인 삽입과 탐색을 가능하게한다. 또한, 서브트리를 다른 이진 트리의 서브트리와 교환하기 쉽다.

이진 트리에는 두 종류의 특별한 형태를 가진 포화 이진 트리(Perfect Binary Tree)와 완전 이진 트리(Complete Binary Tree)가 있다.

- 포화 이진 트리
    - 모든 리프의 깊이가 같고 각 내부 노드가 2개의 자식을 가지는 트리
- 완전 이진 트리
    - 마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차있고, 마지막 레벨에는 노드들이 왼쪽부터 빠짐없이 채워진 트리
    - 포화 이진 트리는 완전 이진 트리이기도 함

<img width="717" alt="image" src="https://github.com/user-attachments/assets/98cdc579-3b15-4713-8892-ba3deedcc774">

- 이진 트리 연산 수행 시간을 분석하기 위한 이진 트리 속성
    - 레벨 k에 있는 최대 노드 수 $2^{k-1}$
        
        단, k=1,2,3,…이다.
        
    - 높이가 h인 포화 이진 트리에 있는 노드 수 :  $2^{h} - 1$
    - n개의 노드를 가진 완전 이진 트리의 높이 : $log_{2}(n+1)$

<img width="712" alt="image" src="https://github.com/user-attachments/assets/7c4f0f48-d250-40a2-838e-3560cf30a6e2">

- 이진 트리에서 부모 노드와 자식 노드 구하는 방법
    - 부모 노드 구하는 법 : $n/2$
    - 자식 노드 구하는 법
        - 왼쪽 :  $n*2$
        - 오른쪽 : $(n*2)+1$

<img width="705" alt="image" src="https://github.com/user-attachments/assets/51a0807a-f40b-4761-9940-0a282c38500d">

완전 이진 트리를 저장하기 위해서 배열을 사용하면 레퍼런스 저장할 메모리 공간이 필요 없으므로 매우 효율적이다.

그러나 편향(Skedwed) 이진트리를 배열에 저장하는 경우 트리의 높이가 높아질 수록 메모리 낭비가 심해진다.

<img width="713" alt="image" src="https://github.com/user-attachments/assets/68a977aa-392f-4276-899f-d337af1be1f9">

이런 경우 LinkedList를 사용하는게 좋다.

하지만 접근 수행 시간은 배열인 경우 O(1), linkedlist인 경우 O(n)이라는 것을 기억하자.

## 3. 이진 트리의 연산

### 트리 순회 방식 4가지

- 전위 순회(Preorder Traversal)
- 중위 순회(Inorder Traversal)
- 후위 순회(Postorder Traversal)
- 레벨 순회(Levelorder Traversal)

### 전위 순회

부모(루트) 노드 먼저 읽는다. ⇒ 부모, 왼쪽, 오른쪽

<img width="711" alt="image" src="https://github.com/user-attachments/assets/c12aa2c6-6403-4caa-8a81-543dc947d45d">

### 중위 순회

왼쪽 서브트리 모두 방문 후 부모 노드를 방문한다. ⇒ 왼쪽, 부모, 오른쪽

화살표 아래로 쭉쭉 그어서 순서대로 읽으면 쉬움

<img width="711" alt="image" src="https://github.com/user-attachments/assets/9e933de2-d817-4b7d-81a0-1110c0999d66">

### 후위 순회

왼쪽 서브트리 방문 후 오른쪽 서브트리 순회하고 부모 노드 방문 ⇒ 왼쪽, 오른쪽, 부모

<img width="717" alt="image" src="https://github.com/user-attachments/assets/1f727669-f186-424a-bc3e-7c3d3156d791">

### 레벨 순회

큐를 이용하여 순회를 한다. 꺼낼 때마다 자식이 존재하면 큐의 뒤에 넣는다.

<img width="688" alt="image" src="https://github.com/user-attachments/assets/209dcc00-f935-4640-ad1f-d7f2b20b2043">

### 이진 트리 관련 연산

- size() : 트리의 노드 수 계산
- height() : 트리의 높이 계산
- isEqual() : 2개의 이진 트리에 대한 동일성 검사

size()와 height()는 후위 순위에 기반하고, isEqual()은 전위 순회에 기반한다.

**size() 계산 방법**

- 루트를 인자로 전달하여 호출하고
- 노드가
    - null이면 0을 반환
    - null이 아니면 왼쪽 자식을 루트로하는 서브트리 노드 수와 오른쪽 자식을 루트로하는 서브트리 노드 수를 더한 결과에 + 1을 해주고 반환

**height() 계산 방법**

- 자신의 높이를 계산하는 방법은 내려갈 때마다 `count + 1`을 해주는 것이다.

**isEqual() 계산 방법**

- 두개 트리의 루트를 인자로 전달
- 두개의 노드 중
    - 둘 다 null이면 true
    - 하나만 null이면 false(트리가 다른 것이므로)
    - 둘 다 null이면 두 노드의 키를 비교
        - 키가 다르면(양수, 음수인 경우) false
        - 0이면(같은 key를 가짐) isEqual() 메소드 재귀호출

### 💡포인트

- 각각의 연산 수행시간 : O(n)
    - 한 번씩만 방문하기 때문임

## 4. 서로소 집합을 위한 트리 연산

서로소 집합이란 어느 두 집합도 공통된 원소를 갖지 않는 경우를 뜻 한다.

서로소 집합을 메모리에 저장하기 위해서 1차원 배열을 사용하면 된다.

집합에 속한 원소들 사이에 특정한 순서가 없고, 중복된 원소가 없으므로 1차원 배열에 저장이 가능하다.

### 서로소 집합에 수행할 연산 : union, find

union 연산 : 2개의 집합을 하나로 만드는 연산

find 연산 :  루트를 찾는 연산

<img width="705" alt="image" src="https://github.com/user-attachments/assets/cce171ae-c809-4e9c-9419-ce084d2ea0df">

union 연산을 수행할 때 트리를 합쳐야 되는 것이기 때문에 find연산을 수행해야되기 때문에 트리의 높이가 낮을 수록 수행시간을 줄일 수 있다.

### 💡포인트

- find연산을 제외한 순수 union 연산
    - O(1)
- find연산
    - O(log*n)

## 요약

- 트리는 계층적 자료구조로서 배열이나 연결 리스트의 단점을 보완하는 자료구조
- 왼쪽 자식-오른쪽 형제 표현은 노드의 차수가 일정하지 않은 일반적인 트리를 구현하는 매우 효율적인 자료구조
- 포화 이진 트리는 모든 리프의 깊이가 같고 각 내부 노드가 2개의 자식을 가지는 트리
    - 완전 이진 트리이기도 함
- 완전 이진 트리는 마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차 있고, 마지막 레벨에는 노드들이 왼쪽부터 빠짐없이 채워진 트리
- 이진 트리의 순회 방법은 전위 순회, 중위 순회, 후위 순회, 그리고 레벨 순회가 있음
- 레벨 순회는 튜 자료구조를 사용해서 구현
- 이진 트리의 높이 계산과 노드 수의 계산에는 후위 순회가 적합하고, 이진 트리의 비교에는 전위 순회가 적합
- 스택 없이 이진 트리를 순회하기 위해 노드의 null 레퍼런스 대신 다음에 방문할 노드의 레퍼런스를 저장한 이진 트리를 스레드 이진 트리라고 함
- 이진 트리의 높이 및 노드 수의 계산, 각 트리 순회, 동일성 검사는 트리의 모든 노드를 방문해야하므로 각각 O(n) 시간이 소요됨
- 서로소 집합의 union과 find 연산을 효율적으로 수행하기 위해, union은 rank 기반 연산을 수행하고, find 연산은 경로 압축을 수행함
- union 연산의 수행 시간은 O(1) 시간이고, find 연산의 수행 시간은 O(log*n)
- union-find 연산은 Kruskal의 최소 신상 트리 알고리즘, 트리에서 가장 가까운 공통 조상 노드 찾기, 네트워크의 연결 검사, 퍼콜레이션, 이미지 처리, 조각 그림 맞추기, 바둑 같은 게임 등에 활용됨
