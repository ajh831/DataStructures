> 목차
1. 스택
2. 큐
3. 데크
> 

## 1. 스택(Stack)

스택은 한쪽 끝에서만 항목을 삭제하거나 새로운 항목을 저장하는 자료구조이다.(LIFO)

스택 연산 방법(필수 요소)

- push() : 새로운 항목 저장하기
- pop() : 가장 위에 있는 항목 꺼내기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/6e7b24b7-8a81-400c-a724-8330697d2f1e/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/5564899f-b0d8-49b9-9768-3c31d134e490/Untitled.png)

스택을 배열로 구현하는 경우 top은 저장된 배열 원소의 인덱스를 갖는다.

단, 스택에 비어있는 경우, `top = -1` 이다.

스택을 배열로 구현한 경우 발생하는 문제점이 2가지가 존재한다.

1. 스택이 꽉 찬 경우
2. 스택의 항목이 1/4만 차지하게 되어 메모리를 낭비하는 경우

아래는 두 가지 문제를 해결하기위한 방법이다.

1. 스택이 꽉찬 경우
    - 스택을 2배의 크기로 확장한다.
2. 스택의 항목이 1/4만 차지하게 되어 메모리를 낭비하는 경우
    - 스택을 1/2 크기로 축소한다.

### 스택을 활용하여 구현할 수 있는 예시

1. 괄호 짝맞추기
2. 회문 검사하기
3. 피연산자 표기법 변경하기

### 💡포인트

- 배열로 구현된 스택 push(), pop() : O(1)
    - 맨 위에 넣고 빼는 작업이기 때문에 O(1) 시간이 걸린다.
- 배열의 크기를 변경하는 경우 : O(n)
    - 모든 항목을 새로운 배열로 복사해야 되기 때문에

## 2. 큐(Queue)

큐는 쉽게 표현한다면 줄서기라고 할 수 있으며 삽입과 삭제가 양 끝에서 각각 수행되는 자료구조이다.(FIFO)

큐 연산 방법(필수 요소)

- add() : 새로운 항목 저장하기
- remove() : 가장 위에 있는 항목 꺼내기

큐를 배열로 구현하는 경우 삽입, 삭제 연산을 거듭하게 되는 경우 큐의 항목이 배열 오른쪽으로 편중되는 문제가 발생하기 때문이다.(새 항목은 뒤에서 삽입되고, 삭제는 앞에서 일어나기 때문)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/408734eb-a993-40fe-b15a-cc12cfa34845/Untitled.png)

이 경우 항목을 이동하지 않고 시작 노드와 끝 노드의 위치를 지정해준다면 배열도 큐로 이용이 가능하다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/a76cfd0e-00e3-4117-bbf2-85c5ed80a158/Untitled.png)

처음과 마지막의 위치를 옮겨주는 경우에도 또다른 문제가 발생한다.

요소를 전부 삭제하는 경우 rear가 삭제된 항목이 있던 곳을 계속 가리키고 있는 문제이다.

이 문제를 해결하기 위해서 empty가 되는 경우 `front = rear = 0`이 되도록 하는 것이다. 하지만 이러한 방법은 효율성을 떨어트린다고 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/a009a03e-7c91-4227-b7f8-90a8e0f2b98c/Untitled.png)

또한, 꽉 찬 경우도 front와 rear가 같은 곳을 가리키고 있기 때문에 배열이 비어있는 건지 꽉 찬건지 알 수가 없다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/ca318554-ed2b-4c02-bcca-855a2e353946/Untitled.png)

이 문제를 해결하는 방법은 n-1 위치를 비워주는 것이다.(linkedlist인 경우는 비워주지 않아도 괜찮음)

front == rear 가 되면 초기 상태랑 동일해지는 것을 알 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/dcb83837-3efb-432a-bcef-ad5107e376d6/Untitled.png)

### 💡포인트

- 배열로 구현된 큐 add(), remove() : O(1)
    - 추가할때는 요소 맨 뒤에 추가가 되고, 삭제할때는 맨 앞 요소를 삭제 하기 때문에 O(1) 시간이 걸린다.
- 배열의 크기를 변경하는 경우 : O(n)
    - 모든 항목을 새로운 배열로 복사해야 되기 때문에

## 3. 데크(Deque)

데크는 양쪽 끝에서 삽입과 삭제를 허용하는 자료구조이다.

스택과 큐를 혼합한 자료구조이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7e1e85e-d6f9-43d3-8475-0933babeaf4a/be9ba000-cd28-42c7-a69a-b59d93346954/Untitled.png)

### 데크을 활용하여 구현할 수 있는 예시

1. 스크롤(Scroll)
2. 문서 편집기 등의 undo 연산
3. 웹 브라우저의 방문 기록
    - 최근 방문한 페이지 주소는 앞에 삽입하고, 일정 수가 삽입되면 뒤에서 부터 삭제

데크는 1차원 배열로 구현할 수 있다. 큐와 같이 front가 맨 앞에 있는 요소의 직전 요소를 가리킨다.

데크를 이중 연결 리스트로 구현할 수도 있다. 이 때 rear가 가리키는 노드의 이전 노드의 레퍼런스를 알고 있어야지 삭제가 가능하다.

### 💡포인트

- 배열, 이중 연결 리스트로 구현한 경우
    - 스택과 큐의 연산 수행 시간과 동일하다.

## 요약

배열과 연결 리스트들의 최악의 경우 빅오(O) 수행 시간 비교

### 스택, 큐, 데크

- 배열로 구현한 경우
    - 삽입 : O(1)
    - 삭제 : O(1)
- 연결리스트로 구현한 경우(데크는 이중 연결리스트)
    - 삽입 : O(1)
    - 삭제 : O(1)
